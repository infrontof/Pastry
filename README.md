Pastry
======

Using the actor model the Pastry protocol and a simple object access service to prove its usefulness. Implement in Scala.

Pastry_nofail.scala
        After compile,runing project3 numNodes  numRequests to run the program. NumNodes of node will join in the Pastry one by one. Each node will gets its own leaf tables and route tables by join. When one node built up and update all its tables, it will begin to send message. Each node will send numRequests message. Each request it use a random String in the ID range as the key. Passing each node will make the hop add 1.When the message arrives, the initial sender will receive a Message Arrive message and give the hops number it passed. When all nodes receive all the message arrive message for all the message be sent and the average number of hops will be calculated, the Pastry will stop and exit.

Pastry_fail.scala (got nodes failed after join the pastry)
After compile,runing project3 numNodes  numRequests test to run the program. NumNodes of node will join in the Pastry one by one. Each node will gets its own leaf tables and route tables by join. When one node built up and update all its tables, it will begin to send message. Each node will send numRequests message. Each request it use a random String in the ID range as the key. Passing each node will make the hop add 1.When the message arrives, the initial sender will receive a Message Arrive message and give the hops number it passed. When all nodes receive all the message arrive message for all the message be sent and the average number of hops will be calculated, the Pastry will stop and exit. 
 If the third argument is test, then the program will random generate some fail. If the connect give fail message back for 3 times, then the connection can be seen as the failed permanently or it will wake up to make a temporarily fail connection, which is defined in initialization.The permanently failed connection will cause the end peers remove each other from its leaf table and route table. And a random node will be set as died to simulate the node dies. When the died node receive message it will give a fail message and  the sender will also remove the died node from its leaf and route table. And in node died case and the permanently connection failed, the end peer will calculate another node to replace it in the tables. So the system will resilient.
